package Mallet::CrfWrapper::WebService;

#
# Package to access CRF model runner via web service
#

use strict;
use warnings;

use Mallet::CrfWrapper;

use LWP::UserAgent;
use HTTP::Request;
use HTTP::Status qw(:constants);
use Encode;
use URI;

use Data::Dumper;

use constant DEFAULT_CRF_PORT => 8441;

#
# Helpers
#

sub _fatal_error($)
{
    my $error_message = shift;
    Mallet::CrfWrapper::_fatal_error( $error_message );
}

# Return true if the response's error was generated by LWP itself and not by
# the server
sub _response_error_is_client_side($)
{
    my $response = shift;

    if ( $response->is_success )
    {
        die "Response was successful, but I have expected an error.\n";
    }

    my $header_client_warning = $response->header( 'Client-Warning' );
    if ( defined $header_client_warning and $header_client_warning =~ /Internal response/ )
    {
        # Error was generated by LWP::UserAgent; likely we didn't reach server
        # at all (timeout, unresponsive host, etc.)
        #
        # http://search.cpan.org/~gaas/libwww-perl-6.05/lib/LWP/UserAgent.pm#$ua->get(_$url_)
        return 1;
    }
    else
    {
        return 0;
    }
}

my $_crf_server_url = 'http://127.0.0.1:8441/crf';

sub set_webservice_url($)
{
    my $crf_server_url = shift;

    my $uri;
    eval { $uri = URI->new( $crf_server_url )->canonical; };
    if ( $@ )
    {
        _fatal_error( "Invalid CRF model runner web service URI: $crf_server_url" );
    }

    # If someone forgot to explicitly set the port
    my $default_protocol_port = 80;
    if ( $uri->port == $default_protocol_port and ( $crf_server_url !~ /:$default_protocol_port/ ) )
    {
        warn( "CRF model runner web service URL's port was not set, to I'm setting it to " . DEFAULT_CRF_PORT );
        $uri->port( DEFAULT_CRF_PORT );
    }

    $_crf_server_url = $uri->as_string;

    say STDERR "CRF model runner web service URL: $_crf_server_url";
}

#
# Mallet::CrfWrapper "implementation"
#

sub create_model($$$)
{
    my ( $class, $training_data_file, $iterations ) = @_;

    # Clients should use Mallet::CrfWrapper::InlineJava directly
    _fatal_error( "Not implemented in " . __PACKAGE__ );
}

sub run_model_inline_java_data_array($$$)
{
    my ( $class, $model_file_name, $test_data_array ) = @_;

    my $test_data = join "\n", @{ $test_data_array };

    # If test data is empty
    unless ( $test_data )
    {
        return [];
    }

    my $test_data_encoded;
    eval {
        # Have to encode because HTTP::Request only accepts bytes as POST data
        $test_data_encoded = Encode::encode_utf8( $test_data );
    };
    if ( $@ )
    {
        _fatal_error( "Unable to encode_utf8() data: $test_data" );
    }

    # Make a request
    my $ua = LWP::UserAgent->new;
    $ua->timeout( 60 );
    $ua->max_size( undef );

    unless ( $_crf_server_url )
    {
        _fatal_error( "Unable to determine CRF model runner web service URL to use." );
    }

    my $request = HTTP::Request->new( POST => $_crf_server_url );
    $request->content_type( 'text/plain; charset=utf8' );
    $request->content( $test_data_encoded );

    my $response = $ua->request( $request );

    my $results_string;
    if ( $response->is_success )
    {
        # OK
        $results_string = $response->decoded_content;
    }
    else
    {
        # Error; determine whether we should be blamed for making a malformed
        # request, or is it an extraction error

        if ( _response_error_is_client_side( $response ) )
        {
            # Error was generated by LWP::UserAgent; likely we didn't reach server
            # at all (timeout, unresponsive host, etc.)
            _fatal_error( 'LWP error: ' . $response->status_line . ': ' . $response->decoded_content );

        }
        else
        {
            # Error was generated by server

            my $http_status_code = $response->code;

            if ( $http_status_code == HTTP_METHOD_NOT_ALLOWED or $http_status_code == HTTP_BAD_REQUEST )
            {
                # Not POST, empty POST
                _fatal_error( $response->status_line . ': ' . $response->decoded_content );

            }
            elsif ( $http_status_code == HTTP_INTERNAL_SERVER_ERROR )
            {
                # CRF processing error -- die() so that the error gets caught and logged into a database
                die( 'CRF web service was unable to process the download: ' . $response->decoded_content );

            }
            else
            {
                # Shutdown the extractor on unconfigured responses
                _fatal_error( 'Unknown HTTP response: ' . $response->status_line . ': ' . $response->decoded_content );
            }
        }
    }

    unless ( $results_string )
    {
        _fatal_error( "Server returned nothing for POST data: " . $test_data );
    }

    my $results = Mallet::CrfWrapper::convert_crf_string_to_arrayref( $results_string );
    unless ( defined $results ) {
        _fatal_error( "CRF results string is undef." );
    }

    return $results;
}

1;
